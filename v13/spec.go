// Code generated by schema-generate. DO NOT EDIT.

package spaceapistruct

import (
	"bytes"
	"encoding/json"
	"errors"
)

// AccountBalanceItems
type AccountBalanceItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// If you have more than one account you can use this field to specify where it is.
	Location string `json:"location,omitempty"`

	// Give your sensor instance a name.
	Name string `json:"name,omitempty"`

	// What's the currency? Please use the ones provided, in the next version you can use currency definitions according to <a href="https://en.wikipedia.org/wiki/ISO_4217" target="_blank">ISO 4217</a>
	Unit string `json:"unit"`

	// How much?
	Value float64 `json:"value"`
}

// AlphaItems
type AlphaItems struct {

	// The conversion from the <em>cpm</em> unit to another unit hardly depends on your tube type. See the description of the value field to see how to use the conversion factor. <strong>Note:</strong> only trust your manufacturer if it comes to the actual factor value. The internet seems <a rel="nofollow" href="http://sapporohibaku.wordpress.com/2011/10/15/conversion-factor/" target="_blank">full of wrong copy & pastes</a>, don't even trust your neighbour hackerspace. If in doubt ask the tube manufacturer.
	ConversionFactor float64 `json:"conversion_factor,omitempty"`

	// The dead time in µs. See the description of the value field to see how to use the dead time.
	DeadTime float64 `json:"dead_time,omitempty"`

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location,omitempty"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// Choose the appropriate unit for your radiation sensor instance.
	Unit string `json:"unit"`

	// Observed counts per minute (ocpm) or actual radiation value. If the value are the observed counts then the dead_time and conversion_factor fields must be defined as well. CPM formula: <div>cpm = ocpm ( 1 + 1 / (1 - ocpm x dead_time) )</div> Conversion formula: <div>µSv/h = cpm x conversion_factor</div>
	Value float64 `json:"value"`
}

// BarometerItems
type BarometerItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// The unit of the sensor value. You should always define the unit though if the sensor is a flag of a boolean type then you can of course omit it.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// BetaGammaItems
type BetaGammaItems struct {

	// The conversion from the <em>cpm</em> unit to another unit hardly depends on your tube type. See the description of the value field to see how to use the conversion factor. <strong>Note:</strong> only trust your manufacturer if it comes to the actual factor value. The internet seems <a rel="nofollow" href="http://sapporohibaku.wordpress.com/2011/10/15/conversion-factor/" target="_blank">full of wrong copy & pastes</a>, don't even trust your neighbour hackerspace. If in doubt ask the tube manufacturer.
	ConversionFactor float64 `json:"conversion_factor,omitempty"`

	// The dead time in µs. See the description of the value field to see how to use the dead time.
	DeadTime float64 `json:"dead_time,omitempty"`

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location,omitempty"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// Choose the appropriate unit for your radiation sensor instance.
	Unit string `json:"unit"`

	// Observed counts per minute (ocpm) or actual radiation value. If the value are the observed counts then the dead_time and conversion_factor fields must be defined as well. CPM formula: <div>cpm = ocpm ( 1 + 1 / (1 - ocpm x dead_time) )</div> Conversion formula: <div>µSv/h = cpm x conversion_factor</div>
	Value float64 `json:"value"`
}

// BetaItems
type BetaItems struct {

	// The conversion from the <em>cpm</em> unit to another unit hardly depends on your tube type. See the description of the value field to see how to use the conversion factor. <strong>Note:</strong> only trust your manufacturer if it comes to the actual factor value. The internet seems <a rel="nofollow" href="http://sapporohibaku.wordpress.com/2011/10/15/conversion-factor/" target="_blank">full of wrong copy & pastes</a>, don't even trust your neighbour hackerspace. If in doubt ask the tube manufacturer.
	ConversionFactor float64 `json:"conversion_factor,omitempty"`

	// The dead time in µs. See the description of the value field to see how to use the dead time.
	DeadTime float64 `json:"dead_time,omitempty"`

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location,omitempty"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// Choose the appropriate unit for your radiation sensor instance.
	Unit string `json:"unit"`

	// Observed counts per minute (ocpm) or actual radiation value. If the value are the observed counts then the dead_time and conversion_factor fields must be defined as well. CPM formula: <div>cpm = ocpm ( 1 + 1 / (1 - ocpm x dead_time) )</div> Conversion formula: <div>µSv/h = cpm x conversion_factor</div>
	Value float64 `json:"value"`
}

// BeverageSupplyItems
type BeverageSupplyItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Room 1</samp> or <samp>Room 2</samp> or <samp>Room 3</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location,omitempty"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// The unit, either <samp>btl</samp> for bottles or <samp>crt</samp> for crates.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// Blog
type Blog struct {

	// Type of the feed, for example <samp>rss</samp>, <samp>atom</atom>, <samp>ical</samp>
	Type string `json:"type,omitempty"`

	// Feed URL
	Url string `json:"url"`
}

// Cache Specifies options about caching of your SpaceAPI endpoint. Use this if you want to avoid hundreds/thousands of application instances crawling your status.
type Cache struct {

	// Cache update cycle. This field must match the basic regular expression <code>^[mhd]\.[0-9]{2}$</code>, where the first field specifies a unit of time (<code>m</code> for 1 minute, <code>h</code> for 1 hour, <code>d</code> for 1 day), and the second field specifies how many of this unit should be skipped between updates. For example, <samp>m.10</samp> means one updates every 10 minutes, <samp>h.03</samp> means one update every 3 hours, and <samp>d.01</samp> means one update every day.
	Schedule string `json:"schedule"`
}

// Calendar
type Calendar struct {

	// Type of the feed, for example <samp>rss</samp>, <samp>atom</atom>, <samp>ical</samp>
	Type string `json:"type,omitempty"`

	// Feed URL
	Url string `json:"url"`
}

// Contact Contact information about your space. You must define at least one which is in the list of allowed values of the issue_report_channels field.
type Contact struct {

	// E-mail address for contacting your space. If this is a mailing list consider to use the contact/ml field.
	Email string `json:"email,omitempty"`

	// Facebook account URL.
	Facebook string `json:"facebook,omitempty"`

	// Foursquare ID, in the form <samp>4d8a9114d85f3704eab301dc</samp>.
	Foursquare string `json:"foursquare,omitempty"`

	// Google services.
	Google *Google `json:"google,omitempty"`

	// Identi.ca or StatusNet account, in the form <samp>yourspace@example.org</samp>
	Identica string `json:"identica,omitempty"`

	// URL of the IRC channel, in the form <samp>irc://example.org/#channelname</samp>
	Irc string `json:"irc,omitempty"`

	// A separate email address for issue reports (see the <em>issue_report_channels</em> field). This value can be Base64-encoded.
	IssueMail string `json:"issue_mail,omitempty"`

	// A public Jabber/XMPP multi-user chatroom in the form <samp>chatroom@conference.example.net</samp>
	Jabber string `json:"jabber,omitempty"`

	// Persons who carry a key and are able to open the space upon request. One of the fields irc_nick, phone, email or twitter must be specified.
	Keymasters []*KeymastersItems `json:"keymasters,omitempty"`

	// The e-mail address of your mailing list. If you use Google Groups then the e-mail looks like <samp>your-group@googlegroups.com</samp>.
	Ml string `json:"ml,omitempty"`

	// Phone number, including country code with a leading plus sign. Example: <samp>+1 800 555 4567</samp>
	Phone string `json:"phone,omitempty"`

	// URI for Voice-over-IP via SIP. Example: <samp>sip:yourspace@sip.example.org</samp>
	Sip string `json:"sip,omitempty"`

	// Twitter handle, with leading @
	Twitter string `json:"twitter,omitempty"`
}

// Direction The wind direction in degrees.
type Direction struct {

	// The unit of the sensor value. You should always define the unit though if the sensor is a flag of a boolean type then you can of course omit it.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// DoorLockedItems
type DoorLockedItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>front door</samp>, <samp>chill room</samp> or <samp>lab</samp>.
	Location string `json:"location"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// The sensor value
	Value bool `json:"value"`
}

// Elevation Height above mean sea level.
type Elevation struct {

	// The unit of the sensor value. You should always define the unit though if the sensor is a flag of a boolean type then you can of course omit it.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// EventsItems
type EventsItems struct {

	// A custom text field to give more information about the event
	Extra string `json:"extra,omitempty"`

	// Name or other identity of the subject (e.g. <samp>J. Random Hacker</samp>, <samp>fridge</samp>, <samp>3D printer</samp>, …)
	Name string `json:"name"`

	// Unix timestamp when the event occurred
	Timestamp float64 `json:"timestamp"`

	// Action (e.g. <samp>check-in</samp>, <samp>check-out</samp>, <samp>finish-print</samp>, …). Define your own actions and use them consistently, canonical actions are not (yet) specified
	Type string `json:"type"`
}

// Feeds Feeds where users can get updates of your space
type Feeds struct {
	Blog     *Blog     `json:"blog,omitempty"`
	Calendar *Calendar `json:"calendar,omitempty"`
	Flickr   *Flickr   `json:"flickr,omitempty"`
	Wiki     *Wiki     `json:"wiki,omitempty"`
}

// Flickr
type Flickr struct {

	// Type of the feed, for example <samp>rss</samp>, <samp>atom</atom>, <samp>ical</samp>
	Type string `json:"type,omitempty"`

	// Feed URL
	Url string `json:"url"`
}

// GammaItems
type GammaItems struct {

	// The conversion from the <em>cpm</em> unit to another unit hardly depends on your tube type. See the description of the value field to see how to use the conversion factor. <strong>Note:</strong> only trust your manufacturer if it comes to the actual factor value. The internet seems <a rel="nofollow" href="http://sapporohibaku.wordpress.com/2011/10/15/conversion-factor/" target="_blank">full of wrong copy & pastes</a>, don't even trust your neighbour hackerspace. If in doubt ask the tube manufacturer.
	ConversionFactor float64 `json:"conversion_factor,omitempty"`

	// The dead time in µs. See the description of the value field to see how to use the dead time.
	DeadTime float64 `json:"dead_time,omitempty"`

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location,omitempty"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// Choose the appropriate unit for your radiation sensor instance.
	Unit string `json:"unit"`

	// Observed counts per minute (ocpm) or actual radiation value. If the value are the observed counts then the dead_time and conversion_factor fields must be defined as well. CPM formula: <div>cpm = ocpm ( 1 + 1 / (1 - ocpm x dead_time) )</div> Conversion formula: <div>µSv/h = cpm x conversion_factor</div>
	Value float64 `json:"value"`
}

// Google Google services.
type Google struct {

	// Google plus URL.
	Plus string `json:"plus,omitempty"`
}

// Gust
type Gust struct {

	// The unit of the sensor value. You should always define the unit though if the sensor is a flag of a boolean type then you can of course omit it.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// HumidityItems
type HumidityItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// The unit of the sensor value. You should always define the unit though if the sensor is a flag of a boolean type then you can of course omit it.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// Icon Icons that show the status graphically
type Icon struct {

	// The URL to your customized space logo showing a closed space
	Closed string `json:"closed"`

	// The URL to your customized space logo showing an open space
	Open string `json:"open"`
}

// KeymastersItems
type KeymastersItems struct {

	// Email address which can be base64 encoded.
	Email string `json:"email,omitempty"`

	// Contact the person with this nickname directly in irc if available. The irc channel to be used is defined in the contact/irc field.
	IrcNick string `json:"irc_nick,omitempty"`

	// Real name
	Name string `json:"name,omitempty"`

	// Example: <samp>['+1 800 555 4567','+1 800 555 4544']</samp>
	Phone string `json:"phone,omitempty"`

	// Twitter username with leading <samp>@</samp>.
	Twitter string `json:"twitter,omitempty"`
}

// Location Position data such as a postal address or geographic coordinates
type Location struct {

	// The postal address of your space (street, block, housenumber, zip code, city, whatever you usually need in your country, and the country itself).<br>Examples: <ul><li>Netzladen e.V., Breite Straße 74, 53111 Bonn, Germany</li></ul>
	Address string `json:"address,omitempty"`

	// Latitude of your space location, in degree with decimal places. Use positive values for locations north of the equator, negative values for locations south of equator.
	Lat float64 `json:"lat"`

	// Longitude of your space location, in degree with decimal places. Use positive values for locations east of Greenwich, and negative values for locations west of Greenwich.
	Lon float64 `json:"lon"`
}

// MachinesItems
type MachinesItems struct {

	// The machine's MAC address of the format <samp>D3:3A:DB:EE:FF:00</samp>.
	Mac string `json:"mac"`

	// The machine name.
	Name string `json:"name,omitempty"`
}

// NetworkConnectionsItems
type NetworkConnectionsItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location,omitempty"`

	// The machines that are currently connected with the network.
	Machines []*MachinesItems `json:"machines,omitempty"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// This field is optional but you can use it to the network type such as <samp>wifi</samp> or <samp>cable</samp>. You can even expose the number of <a href="https://spacefed.net/wiki/index.php/Spacenet" target="_blank">spacenet</a>-authenticated connections.
	Type string `json:"type,omitempty"`

	// The amount of network connections.
	Value float64 `json:"value"`
}

// PeopleNowPresentItems
type PeopleNowPresentItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// If you use multiple sensor instances for different rooms, use this field to indicate the location.
	Location string `json:"location,omitempty"`

	// Give this sensor a name if necessary at all. Use the location field for the rooms. This field is not intended to be used for names of hackerspace members. Use the field 'names' instead.
	Name string `json:"name,omitempty"`

	// List of hackerspace members that are currently occupying the space.
	Names []string `json:"names,omitempty"`

	// The amount of present people.
	Value float64 `json:"value"`
}

// PowerConsumptionItems
type PowerConsumptionItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// The unit of the sensor value. You should always define the unit though if the sensor is a flag of a boolean type then you can of course omit it.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// Properties
type Properties struct {

	// The wind direction in degrees.
	Direction *Direction `json:"direction"`

	// Height above mean sea level.
	Elevation *Elevation `json:"elevation"`
	Gust      *Gust      `json:"gust"`
	Speed     *Speed     `json:"speed"`
}

// Radiation Compound radiation sensor. Check this <a rel="nofollow" href="https://sites.google.com/site/diygeigercounter/gm-tubes-supported" target="_blank">resource</a>.
type Radiation struct {

	// An alpha sensor
	Alpha []*AlphaItems `json:"alpha,omitempty"`

	// A beta sensor
	Beta []*BetaItems `json:"beta,omitempty"`

	// A sensor which cannot filter beta and gamma radiation separately.
	BetaGamma []*BetaGammaItems `json:"beta_gamma,omitempty"`

	// A gamma sensor
	Gamma []*GammaItems `json:"gamma,omitempty"`
}

// RadioShowItems
type RadioShowItems struct {

	// Specify the end time by using the <a href="http://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601</a> standard. This encodes the time as follows: <br><br><ul><li>Combined date and time in UTC: 2013-06-10T10:00Z</li><li>Combined date and time in localtime with the timezone offset: 2013-06-10T12:00+02:00</li><li>Combined date and time in localtime with the timezone offset: 2013-06-10T07:00-03:00</li></ul> The examples refer all to the same time.
	End string `json:"end"`

	// The name of the radio show.
	Name string `json:"name"`

	// Specify the start time by using the <a href="http://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601</a> standard. This encodes the time as follows: <br><br><ul><li>Combined date and time in UTC: 2013-06-10T10:00Z</li><li>Combined date and time in localtime with the timezone offset: 2013-06-10T12:00+02:00</li><li>Combined date and time in localtime with the timezone offset: 2013-06-10T07:00-03:00</li></ul> The examples refer all to the same time.
	Start string `json:"start"`

	// The stream encoder.
	Type string `json:"type"`

	// The stream URL which must end in a filename or a semicolon such as <br><ul><li>http://signal.hackerspaces.org:8090/signal.mp3</li><li>http://85.214.64.213:8060/;</ul>
	Url string `json:"url"`
}

// Root SpaceAPI 0.13
type Root struct {

	// The version of SpaceAPI your endpoint uses
	Api string `json:"api"`

	// Specifies options about caching of your SpaceAPI endpoint. Use this if you want to avoid hundreds/thousands of application instances crawling your status.
	Cache *Cache `json:"cache,omitempty"`

	// URL(s) of webcams in your space
	Cam []string `json:"cam,omitempty"`

	// Contact information about your space. You must define at least one which is in the list of allowed values of the issue_report_channels field.
	Contact *Contact `json:"contact"`

	// Events which happened recently in your space and which could be interesting to the public, like 'User X has entered/triggered/did something at timestamp Z'
	Events []*EventsItems `json:"events,omitempty"`

	// Feeds where users can get updates of your space
	Feeds *Feeds `json:"feeds,omitempty"`

	// This array defines all communication channels where you want to get automated issue reports about your SpaceAPI endpoint from the revalidator. This field is meant for internal usage only and it should never be consumed by any app. At least one channel must be defined. Please consider that when using <samp>ml</samp> the mailing list moderator has to moderate incoming emails or add the sender email to the subscribers. If you don't break your SpaceAPI implementation you won't get any notifications ;-)
	IssueReportChannels []string `json:"issue_report_channels"`

	// Position data such as a postal address or geographic coordinates
	Location *Location `json:"location"`

	// URL to your space logo
	Logo string `json:"logo"`

	// Your project sites (links to GitHub, wikis or wherever your projects are hosted)
	Projects []string `json:"projects,omitempty"`

	// A list of radio shows that your hackerspace might broadcast.
	RadioShow []*RadioShowItems `json:"radio_show,omitempty"`

	// Data of various sensors in your space (e.g. temperature, humidity, amount of Club-Mate left, …). The only canonical property is the <em>temp</em> property, additional sensor types may be defined by you. In this case, you are requested to share your definition for inclusion in this specification.
	Sensors *Sensors `json:"sensors,omitempty"`

	// The name of your space
	Space string `json:"space"`

	// A flag indicating if the hackerspace uses SpaceFED, a federated login scheme so that visiting hackers can use the space WiFi with their home space credentials.
	Spacefed *Spacefed `json:"spacefed,omitempty"`

	// A collection of status-related data: actual open/closed status, icons, last change timestamp etc.
	State *State `json:"state"`

	// A mapping of stream types to stream URLs. If you use other stream types make a <a href="https://github.com/spaceapi/schema/pulls" target="_blank">pull request</a> or prefix yours with <samp>ext_</samp>.
	Stream *Stream `json:"stream,omitempty"`

	// URL to your space website
	Url string `json:"url"`
}

// Sensors Data of various sensors in your space (e.g. temperature, humidity, amount of Club-Mate left, …). The only canonical property is the <em>temp</em> property, additional sensor types may be defined by you. In this case, you are requested to share your definition for inclusion in this specification.
type Sensors struct {

	// How rich is your hackerspace?
	AccountBalance []*AccountBalanceItems `json:"account_balance,omitempty"`

	// Barometer sensor
	Barometer []*BarometerItems `json:"barometer,omitempty"`

	// How much Mate and beer is in your fridge?
	BeverageSupply []*BeverageSupplyItems `json:"beverage_supply,omitempty"`

	// Sensor type to indicate if a certain door is locked.
	DoorLocked []*DoorLockedItems `json:"door_locked,omitempty"`

	// Humidity sensor
	Humidity []*HumidityItems `json:"humidity,omitempty"`

	// This sensor type is to specify the currently active  ethernet or wireless network devices. You can create different instances for each network type.
	NetworkConnections []*NetworkConnectionsItems `json:"network_connections,omitempty"`

	// Specify the number of people that are currently in your space. Optionally you can define a list of names.
	PeopleNowPresent []*PeopleNowPresentItems `json:"people_now_present,omitempty"`

	// The power consumption of a specific device or of your whole space.
	PowerConsumption []*PowerConsumptionItems `json:"power_consumption,omitempty"`

	// Compound radiation sensor. Check this <a rel="nofollow" href="https://sites.google.com/site/diygeigercounter/gm-tubes-supported" target="_blank">resource</a>.
	Radiation *Radiation `json:"radiation,omitempty"`

	// Temperature sensor. To convert from one unit of temperature to another consider <a href="http://en.wikipedia.org/wiki/Temperature_conversion_formulas" target="_blank">Wikipedia</a>.
	Temperature []*TemperatureItems `json:"temperature,omitempty"`

	// Specify the number of space members.
	TotalMemberCount []*TotalMemberCountItems `json:"total_member_count,omitempty"`

	// Your wind sensor.
	Wind []*WindItems `json:"wind,omitempty"`
}

// Spacefed A flag indicating if the hackerspace uses SpaceFED, a federated login scheme so that visiting hackers can use the space WiFi with their home space credentials.
type Spacefed struct {

	// See the <a target="_blank" href="https://spacefed.net/wiki/index.php/Category:Howto/Spacenet">wiki</a>.
	Spacenet bool `json:"spacenet"`

	// See the <a target="_blank" href="https://spacefed.net/wiki/index.php/Category:Howto/Spacephone">wiki</a>.
	Spacephone bool `json:"spacephone"`

	// See the <a target="_blank" href="https://spacefed.net/wiki/index.php/Category:Howto/Spacesaml">wiki</a>.
	Spacesaml bool `json:"spacesaml"`
}

// Speed
type Speed struct {

	// The unit of the sensor value. You should always define the unit though if the sensor is a flag of a boolean type then you can of course omit it.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// State A collection of status-related data: actual open/closed status, icons, last change timestamp etc.
type State struct {

	// Icons that show the status graphically
	Icon *Icon `json:"icon,omitempty"`

	// The Unix timestamp when the space status changed most recently
	Lastchange float64 `json:"lastchange,omitempty"`

	// An additional free-form string, could be something like <samp>'open for public'</samp>, <samp>'members only'</samp> or whatever you want it to be
	Message string `json:"message,omitempty"`

	// A flag which indicates if the space is currently open or closed. The state 'undefined' can be achieved by assigning this field the value 'null' (without the quotes). In most (all?) programming languages this is evaluated to false so that no app should break
	Open interface{} `json:"open"`

	// The person who lastly changed the state e.g. opened or closed the space.
	TriggerPerson string `json:"trigger_person,omitempty"`
}

// Stream A mapping of stream types to stream URLs. If you use other stream types make a <a href="https://github.com/spaceapi/schema/pulls" target="_blank">pull request</a> or prefix yours with <samp>ext_</samp>.
type Stream struct {

	// Your mpg stream URL. Example: <samp>{"mp4": "http://example.org/stream.mpg"}</samp>
	M4 string `json:"m4,omitempty"`

	// Your mjpeg stream URL. Example: <samp>{"mjpeg": "http://example.org/stream.mjpeg"}</samp>
	Mjpeg string `json:"mjpeg,omitempty"`

	// Your ustream stream URL. Example: <samp>{"ustream": "http://www.ustream.tv/channel/hackspsps"}</samp>
	Ustream string `json:"ustream,omitempty"`
}

// TemperatureItems
type TemperatureItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// The unit of the sensor value.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// TotalMemberCountItems
type TotalMemberCountItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// Specify the location if your hackerspace has different departments (for whatever reason). This field is for one department. Every department should have its own sensor instance.
	Location string `json:"location,omitempty"`

	// You can use this field to specify if this sensor instance counts active or inactive members.
	Name string `json:"name,omitempty"`

	// The amount of your space members.
	Value float64 `json:"value"`
}

// Wiki
type Wiki struct {

	// Type of the feed, for example <samp>rss</samp>, <samp>atom</atom>, <samp>ical</samp>
	Type string `json:"type,omitempty"`

	// Feed URL
	Url string `json:"url"`
}

// WindItems
type WindItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name       string      `json:"name,omitempty"`
	Properties *Properties `json:"properties"`
}

func (strct *AccountBalanceItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccountBalanceItems) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *AlphaItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "conversion_factor" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"conversion_factor\": ")
	if tmp, err := json.Marshal(strct.ConversionFactor); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "dead_time" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"dead_time\": ")
	if tmp, err := json.Marshal(strct.DeadTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AlphaItems) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "conversion_factor":
			if err := json.Unmarshal([]byte(v), &strct.ConversionFactor); err != nil {
				return err
			}
		case "dead_time":
			if err := json.Unmarshal([]byte(v), &strct.DeadTime); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *BarometerItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Location" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BarometerItems) UnmarshalJSON(b []byte) error {
	locationReceived := false
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
			locationReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if location (a required property) was received
	if !locationReceived {
		return errors.New("\"location\" is required but was not present")
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *BetaGammaItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "conversion_factor" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"conversion_factor\": ")
	if tmp, err := json.Marshal(strct.ConversionFactor); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "dead_time" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"dead_time\": ")
	if tmp, err := json.Marshal(strct.DeadTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BetaGammaItems) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "conversion_factor":
			if err := json.Unmarshal([]byte(v), &strct.ConversionFactor); err != nil {
				return err
			}
		case "dead_time":
			if err := json.Unmarshal([]byte(v), &strct.DeadTime); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *BetaItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "conversion_factor" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"conversion_factor\": ")
	if tmp, err := json.Marshal(strct.ConversionFactor); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "dead_time" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"dead_time\": ")
	if tmp, err := json.Marshal(strct.DeadTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BetaItems) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "conversion_factor":
			if err := json.Unmarshal([]byte(v), &strct.ConversionFactor); err != nil {
				return err
			}
		case "dead_time":
			if err := json.Unmarshal([]byte(v), &strct.DeadTime); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *BeverageSupplyItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BeverageSupplyItems) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *Blog) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Blog) UnmarshalJSON(b []byte) error {
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		}
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *Cache) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Schedule" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "schedule" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"schedule\": ")
	if tmp, err := json.Marshal(strct.Schedule); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Cache) UnmarshalJSON(b []byte) error {
	scheduleReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "schedule":
			if err := json.Unmarshal([]byte(v), &strct.Schedule); err != nil {
				return err
			}
			scheduleReceived = true
		}
	}
	// check if schedule (a required property) was received
	if !scheduleReceived {
		return errors.New("\"schedule\" is required but was not present")
	}
	return nil
}

func (strct *Calendar) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Calendar) UnmarshalJSON(b []byte) error {
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		}
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *Direction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Direction) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *DoorLockedItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Location" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DoorLockedItems) UnmarshalJSON(b []byte) error {
	locationReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
			locationReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if location (a required property) was received
	if !locationReceived {
		return errors.New("\"location\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *Elevation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Elevation) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *EventsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "extra" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extra\": ")
	if tmp, err := json.Marshal(strct.Extra); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Timestamp" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "timestamp" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"timestamp\": ")
	if tmp, err := json.Marshal(strct.Timestamp); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EventsItems) UnmarshalJSON(b []byte) error {
	nameReceived := false
	timestampReceived := false
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "extra":
			if err := json.Unmarshal([]byte(v), &strct.Extra); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		case "timestamp":
			if err := json.Unmarshal([]byte(v), &strct.Timestamp); err != nil {
				return err
			}
			timestampReceived = true
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		}
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	// check if timestamp (a required property) was received
	if !timestampReceived {
		return errors.New("\"timestamp\" is required but was not present")
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}

func (strct *Flickr) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Flickr) UnmarshalJSON(b []byte) error {
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		}
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *GammaItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "conversion_factor" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"conversion_factor\": ")
	if tmp, err := json.Marshal(strct.ConversionFactor); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "dead_time" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"dead_time\": ")
	if tmp, err := json.Marshal(strct.DeadTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GammaItems) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "conversion_factor":
			if err := json.Unmarshal([]byte(v), &strct.ConversionFactor); err != nil {
				return err
			}
		case "dead_time":
			if err := json.Unmarshal([]byte(v), &strct.DeadTime); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *Gust) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Gust) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *HumidityItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Location" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HumidityItems) UnmarshalJSON(b []byte) error {
	locationReceived := false
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
			locationReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if location (a required property) was received
	if !locationReceived {
		return errors.New("\"location\" is required but was not present")
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *Icon) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Closed" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "closed" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"closed\": ")
	if tmp, err := json.Marshal(strct.Closed); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Open" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "open" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"open\": ")
	if tmp, err := json.Marshal(strct.Open); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Icon) UnmarshalJSON(b []byte) error {
	closedReceived := false
	openReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "closed":
			if err := json.Unmarshal([]byte(v), &strct.Closed); err != nil {
				return err
			}
			closedReceived = true
		case "open":
			if err := json.Unmarshal([]byte(v), &strct.Open); err != nil {
				return err
			}
			openReceived = true
		}
	}
	// check if closed (a required property) was received
	if !closedReceived {
		return errors.New("\"closed\" is required but was not present")
	}
	// check if open (a required property) was received
	if !openReceived {
		return errors.New("\"open\" is required but was not present")
	}
	return nil
}

func (strct *Location) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "address" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Lat" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "lat" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"lat\": ")
	if tmp, err := json.Marshal(strct.Lat); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Lon" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "lon" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"lon\": ")
	if tmp, err := json.Marshal(strct.Lon); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Location) UnmarshalJSON(b []byte) error {
	latReceived := false
	lonReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "address":
			if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
			}
		case "lat":
			if err := json.Unmarshal([]byte(v), &strct.Lat); err != nil {
				return err
			}
			latReceived = true
		case "lon":
			if err := json.Unmarshal([]byte(v), &strct.Lon); err != nil {
				return err
			}
			lonReceived = true
		}
	}
	// check if lat (a required property) was received
	if !latReceived {
		return errors.New("\"lat\" is required but was not present")
	}
	// check if lon (a required property) was received
	if !lonReceived {
		return errors.New("\"lon\" is required but was not present")
	}
	return nil
}

func (strct *MachinesItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Mac" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "mac" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"mac\": ")
	if tmp, err := json.Marshal(strct.Mac); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MachinesItems) UnmarshalJSON(b []byte) error {
	macReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "mac":
			if err := json.Unmarshal([]byte(v), &strct.Mac); err != nil {
				return err
			}
			macReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		}
	}
	// check if mac (a required property) was received
	if !macReceived {
		return errors.New("\"mac\" is required but was not present")
	}
	return nil
}

func (strct *NetworkConnectionsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "machines" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"machines\": ")
	if tmp, err := json.Marshal(strct.Machines); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NetworkConnectionsItems) UnmarshalJSON(b []byte) error {
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "machines":
			if err := json.Unmarshal([]byte(v), &strct.Machines); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *PeopleNowPresentItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "names" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"names\": ")
	if tmp, err := json.Marshal(strct.Names); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PeopleNowPresentItems) UnmarshalJSON(b []byte) error {
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "names":
			if err := json.Unmarshal([]byte(v), &strct.Names); err != nil {
				return err
			}
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *PowerConsumptionItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Location" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PowerConsumptionItems) UnmarshalJSON(b []byte) error {
	locationReceived := false
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
			locationReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if location (a required property) was received
	if !locationReceived {
		return errors.New("\"location\" is required but was not present")
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *Properties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Direction" field is required
	if strct.Direction == nil {
		return nil, errors.New("direction is a required field")
	}
	// Marshal the "direction" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"direction\": ")
	if tmp, err := json.Marshal(strct.Direction); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Elevation" field is required
	if strct.Elevation == nil {
		return nil, errors.New("elevation is a required field")
	}
	// Marshal the "elevation" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"elevation\": ")
	if tmp, err := json.Marshal(strct.Elevation); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Gust" field is required
	if strct.Gust == nil {
		return nil, errors.New("gust is a required field")
	}
	// Marshal the "gust" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"gust\": ")
	if tmp, err := json.Marshal(strct.Gust); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Speed" field is required
	if strct.Speed == nil {
		return nil, errors.New("speed is a required field")
	}
	// Marshal the "speed" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"speed\": ")
	if tmp, err := json.Marshal(strct.Speed); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Properties) UnmarshalJSON(b []byte) error {
	directionReceived := false
	elevationReceived := false
	gustReceived := false
	speedReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "direction":
			if err := json.Unmarshal([]byte(v), &strct.Direction); err != nil {
				return err
			}
			directionReceived = true
		case "elevation":
			if err := json.Unmarshal([]byte(v), &strct.Elevation); err != nil {
				return err
			}
			elevationReceived = true
		case "gust":
			if err := json.Unmarshal([]byte(v), &strct.Gust); err != nil {
				return err
			}
			gustReceived = true
		case "speed":
			if err := json.Unmarshal([]byte(v), &strct.Speed); err != nil {
				return err
			}
			speedReceived = true
		}
	}
	// check if direction (a required property) was received
	if !directionReceived {
		return errors.New("\"direction\" is required but was not present")
	}
	// check if elevation (a required property) was received
	if !elevationReceived {
		return errors.New("\"elevation\" is required but was not present")
	}
	// check if gust (a required property) was received
	if !gustReceived {
		return errors.New("\"gust\" is required but was not present")
	}
	// check if speed (a required property) was received
	if !speedReceived {
		return errors.New("\"speed\" is required but was not present")
	}
	return nil
}

func (strct *RadioShowItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "End" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "end" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"end\": ")
	if tmp, err := json.Marshal(strct.End); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Start" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "start" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"start\": ")
	if tmp, err := json.Marshal(strct.Start); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RadioShowItems) UnmarshalJSON(b []byte) error {
	endReceived := false
	nameReceived := false
	startReceived := false
	typeReceived := false
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "end":
			if err := json.Unmarshal([]byte(v), &strct.End); err != nil {
				return err
			}
			endReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		case "start":
			if err := json.Unmarshal([]byte(v), &strct.Start); err != nil {
				return err
			}
			startReceived = true
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		}
	}
	// check if end (a required property) was received
	if !endReceived {
		return errors.New("\"end\" is required but was not present")
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	// check if start (a required property) was received
	if !startReceived {
		return errors.New("\"start\" is required but was not present")
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *Root) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Api" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "api" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"api\": ")
	if tmp, err := json.Marshal(strct.Api); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "cache" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"cache\": ")
	if tmp, err := json.Marshal(strct.Cache); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "cam" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"cam\": ")
	if tmp, err := json.Marshal(strct.Cam); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Contact" field is required
	if strct.Contact == nil {
		return nil, errors.New("contact is a required field")
	}
	// Marshal the "contact" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"contact\": ")
	if tmp, err := json.Marshal(strct.Contact); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "events" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"events\": ")
	if tmp, err := json.Marshal(strct.Events); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "feeds" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"feeds\": ")
	if tmp, err := json.Marshal(strct.Feeds); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "IssueReportChannels" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "issue_report_channels" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"issue_report_channels\": ")
	if tmp, err := json.Marshal(strct.IssueReportChannels); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Location" field is required
	if strct.Location == nil {
		return nil, errors.New("location is a required field")
	}
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Logo" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "logo" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"logo\": ")
	if tmp, err := json.Marshal(strct.Logo); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "projects" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"projects\": ")
	if tmp, err := json.Marshal(strct.Projects); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "radio_show" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"radio_show\": ")
	if tmp, err := json.Marshal(strct.RadioShow); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "sensors" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"sensors\": ")
	if tmp, err := json.Marshal(strct.Sensors); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Space" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "space" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"space\": ")
	if tmp, err := json.Marshal(strct.Space); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "spacefed" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"spacefed\": ")
	if tmp, err := json.Marshal(strct.Spacefed); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "State" field is required
	if strct.State == nil {
		return nil, errors.New("state is a required field")
	}
	// Marshal the "state" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"state\": ")
	if tmp, err := json.Marshal(strct.State); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "stream" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"stream\": ")
	if tmp, err := json.Marshal(strct.Stream); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Root) UnmarshalJSON(b []byte) error {
	apiReceived := false
	contactReceived := false
	issue_report_channelsReceived := false
	locationReceived := false
	logoReceived := false
	spaceReceived := false
	stateReceived := false
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "api":
			if err := json.Unmarshal([]byte(v), &strct.Api); err != nil {
				return err
			}
			apiReceived = true
		case "cache":
			if err := json.Unmarshal([]byte(v), &strct.Cache); err != nil {
				return err
			}
		case "cam":
			if err := json.Unmarshal([]byte(v), &strct.Cam); err != nil {
				return err
			}
		case "contact":
			if err := json.Unmarshal([]byte(v), &strct.Contact); err != nil {
				return err
			}
			contactReceived = true
		case "events":
			if err := json.Unmarshal([]byte(v), &strct.Events); err != nil {
				return err
			}
		case "feeds":
			if err := json.Unmarshal([]byte(v), &strct.Feeds); err != nil {
				return err
			}
		case "issue_report_channels":
			if err := json.Unmarshal([]byte(v), &strct.IssueReportChannels); err != nil {
				return err
			}
			issue_report_channelsReceived = true
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
			locationReceived = true
		case "logo":
			if err := json.Unmarshal([]byte(v), &strct.Logo); err != nil {
				return err
			}
			logoReceived = true
		case "projects":
			if err := json.Unmarshal([]byte(v), &strct.Projects); err != nil {
				return err
			}
		case "radio_show":
			if err := json.Unmarshal([]byte(v), &strct.RadioShow); err != nil {
				return err
			}
		case "sensors":
			if err := json.Unmarshal([]byte(v), &strct.Sensors); err != nil {
				return err
			}
		case "space":
			if err := json.Unmarshal([]byte(v), &strct.Space); err != nil {
				return err
			}
			spaceReceived = true
		case "spacefed":
			if err := json.Unmarshal([]byte(v), &strct.Spacefed); err != nil {
				return err
			}
		case "state":
			if err := json.Unmarshal([]byte(v), &strct.State); err != nil {
				return err
			}
			stateReceived = true
		case "stream":
			if err := json.Unmarshal([]byte(v), &strct.Stream); err != nil {
				return err
			}
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		}
	}
	// check if api (a required property) was received
	if !apiReceived {
		return errors.New("\"api\" is required but was not present")
	}
	// check if contact (a required property) was received
	if !contactReceived {
		return errors.New("\"contact\" is required but was not present")
	}
	// check if issue_report_channels (a required property) was received
	if !issue_report_channelsReceived {
		return errors.New("\"issue_report_channels\" is required but was not present")
	}
	// check if location (a required property) was received
	if !locationReceived {
		return errors.New("\"location\" is required but was not present")
	}
	// check if logo (a required property) was received
	if !logoReceived {
		return errors.New("\"logo\" is required but was not present")
	}
	// check if space (a required property) was received
	if !spaceReceived {
		return errors.New("\"space\" is required but was not present")
	}
	// check if state (a required property) was received
	if !stateReceived {
		return errors.New("\"state\" is required but was not present")
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *Spacefed) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Spacenet" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "spacenet" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"spacenet\": ")
	if tmp, err := json.Marshal(strct.Spacenet); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Spacephone" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "spacephone" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"spacephone\": ")
	if tmp, err := json.Marshal(strct.Spacephone); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Spacesaml" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "spacesaml" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"spacesaml\": ")
	if tmp, err := json.Marshal(strct.Spacesaml); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Spacefed) UnmarshalJSON(b []byte) error {
	spacenetReceived := false
	spacephoneReceived := false
	spacesamlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "spacenet":
			if err := json.Unmarshal([]byte(v), &strct.Spacenet); err != nil {
				return err
			}
			spacenetReceived = true
		case "spacephone":
			if err := json.Unmarshal([]byte(v), &strct.Spacephone); err != nil {
				return err
			}
			spacephoneReceived = true
		case "spacesaml":
			if err := json.Unmarshal([]byte(v), &strct.Spacesaml); err != nil {
				return err
			}
			spacesamlReceived = true
		}
	}
	// check if spacenet (a required property) was received
	if !spacenetReceived {
		return errors.New("\"spacenet\" is required but was not present")
	}
	// check if spacephone (a required property) was received
	if !spacephoneReceived {
		return errors.New("\"spacephone\" is required but was not present")
	}
	// check if spacesaml (a required property) was received
	if !spacesamlReceived {
		return errors.New("\"spacesaml\" is required but was not present")
	}
	return nil
}

func (strct *Speed) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Speed) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *State) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "icon" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"icon\": ")
	if tmp, err := json.Marshal(strct.Icon); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "lastchange" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"lastchange\": ")
	if tmp, err := json.Marshal(strct.Lastchange); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "message" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"message\": ")
	if tmp, err := json.Marshal(strct.Message); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Open" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "open" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"open\": ")
	if tmp, err := json.Marshal(strct.Open); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "trigger_person" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"trigger_person\": ")
	if tmp, err := json.Marshal(strct.TriggerPerson); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *State) UnmarshalJSON(b []byte) error {
	openReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "icon":
			if err := json.Unmarshal([]byte(v), &strct.Icon); err != nil {
				return err
			}
		case "lastchange":
			if err := json.Unmarshal([]byte(v), &strct.Lastchange); err != nil {
				return err
			}
		case "message":
			if err := json.Unmarshal([]byte(v), &strct.Message); err != nil {
				return err
			}
		case "open":
			if err := json.Unmarshal([]byte(v), &strct.Open); err != nil {
				return err
			}
			openReceived = true
		case "trigger_person":
			if err := json.Unmarshal([]byte(v), &strct.TriggerPerson); err != nil {
				return err
			}
		}
	}
	// check if open (a required property) was received
	if !openReceived {
		return errors.New("\"open\" is required but was not present")
	}
	return nil
}

func (strct *TemperatureItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Location" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TemperatureItems) UnmarshalJSON(b []byte) error {
	locationReceived := false
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
			locationReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if location (a required property) was received
	if !locationReceived {
		return errors.New("\"location\" is required but was not present")
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *TotalMemberCountItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TotalMemberCountItems) UnmarshalJSON(b []byte) error {
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *Wiki) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Wiki) UnmarshalJSON(b []byte) error {
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		}
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *WindItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Location" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Properties" field is required
	if strct.Properties == nil {
		return nil, errors.New("properties is a required field")
	}
	// Marshal the "properties" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"properties\": ")
	if tmp, err := json.Marshal(strct.Properties); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *WindItems) UnmarshalJSON(b []byte) error {
	locationReceived := false
	propertiesReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
			locationReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "properties":
			if err := json.Unmarshal([]byte(v), &strct.Properties); err != nil {
				return err
			}
			propertiesReceived = true
		}
	}
	// check if location (a required property) was received
	if !locationReceived {
		return errors.New("\"location\" is required but was not present")
	}
	// check if properties (a required property) was received
	if !propertiesReceived {
		return errors.New("\"properties\" is required but was not present")
	}
	return nil
}
